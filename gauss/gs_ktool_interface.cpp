/*
 * Copyright (c) 2020 Huawei Technologies Co.,Ltd.
 *
 * openGauss is licensed under Mulan PSL v2.
 * You can use this software according to the terms and conditions of the Mulan PSL v2.
 * You may obtain a copy of Mulan PSL v2 at:
 *
 *          http://license.coscl.org.cn/MulanPSL2
 *
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PSL v2 for more details.
 * -------------------------------------------------------------------------
 *
 * gs_ktool_interface.cpp
 *
 *
 * IDENTIFICATION
 *	  src\common\interfaces\libpq\client_logic_hooks\encryption_hooks\gs_ktool_interface.cpp
 *
 * -------------------------------------------------------------------------
 */

#include "gs_ktool_interface.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <openssl/rand.h>
#include "encrypt_decrypt.h"
#include "aead_aes_hamc_enc_key.h"
#include "cmk_cache_lru.h"

static CmkCacheList *cmk_cache_list = NULL;

extern bool kt_check_algorithm_type(CmkAlgorithm algo_type)
{
    if (algo_type == CmkAlgorithm::RAS_2048) {
        return true;
    } else {
        printf("ERROR(CLIENT): Invalid algorithm, keys generated by gs_ktool are only used for RAS_2048.\n");
    }

    return false;
}

enum KeyPathErrType{
    SUCCEED = 0,
    
    PATH_TOO_LONG,
    PATH_TOO_SHORT,
    PATH_CHAR_INVALID,
    
    USER_INVALID,
    
    FIEL_EXST,
    FILE_NONEXIST,
    FILE_CREAT_ERR,
    FILE_OPEN_ERR,
    
    KEY_INVALID,
    HEAP_ERR
}

const int MAX_KEY_PATH_LEN = 64;
const int MAX_REAL_PATH_LEN = 1024;
const int MIN_KEY_PATH_LEN = 1024;
const char *default_cmk_dir = "/tmp/"
static char *user_name = NULL;

/* the real key path is /default_cmk_dir/user_name/key_path  */
KeyPathErrType check_kms_key_path(const char *cmk_path, char *real_cmk_path, const size_t buflen)
{
    error_t rc = 0;
    char tmp_cmk_path_buf[buflen] = {0};
    
    if (strlen(cmk_key_path) < MIN_KEY_PATH_LEN) {
        return PATH_TOO_SHORT;
    } else if (strlen(cmk_key_path) < MIN_KEY_PATH_LEN > MAX_KEY_PATH_LEN) {
        return PATH_TOO_LONG;
    }
    
    if (user_name == NULL) {
        user_name = get_user_name();
        if (user_name == NULL){
            return USER_INVALID;
        }
    }
    
    rc = sprintf_s(tmp_cmk_path_buf, buflen, "%s/%s/%s", default_cmk_dir, user_name, cmk_path);
    securec_check_c(rc, "", "");
    if (!check_env_value(tmp_cmk_path_buf)) {
        return PATH_CHAR_INVALID;
    }
    
    real_cmk_path = realpath(tmp_cmk_path_buf);
    if (real_cmk_path != NULL) {
        return FILE_EXIST;
    } else {
        return FILE_NOEXIST;
    }
}

KeyPathErrType generate_kms_cmk(const char *real_cmk_path, char *cmk_plain, const size_t buflen)
{
    return SUCCEED;
}

KeyPathErrType write_kms_cmk_plain(const char *real_cmk_path, char *cmk_plain)
{
    FILE *cmk_fn = NULL;
    
    cmk_fn = open(real_cmk_path, "w");
    if (cmk_fn == NULL) {
        return FILE_OPEN_ERR;
    }
    
    write(cmk_fn, cmk_plain);
    
    return SUCCEED;
    
}

KeyPathErrType read_kms_cmk_plain(const char *real_cmk_path, char *cmk_plain, const size_t buflen)
{
    FILE *cmk_fn = NULL;
    
    /* init LRU cache list */
    if (cmk_cache_list == NULL) {
        cmk_cache_list = init_cmk_cache_list();
        if (cmk_cache_list == NULL) {
            return HEAP_ERR;
        }
    }
    
    /* case a : try to get cmk plain from cache */
    if (!get_cmk_from_cache(cmk_cache_list, cmk_id, cmk_plain)) {
        /* case b : failed to get cmk plian from cache, try to get it from file */
        cmk_fn = open(real_cmk_path, "r");
        if (cmk_fn == NULL) {
            printf("ERROR: ")
            return FILE_OPEN_ERR;
        }
        
        read(cmk_fn, cmk_plain, 100);
        push_cmk_to_cache();
        
        return  SUCCEED;
    }
    
    return SUCCEED;
}



bool kt_atoi(const char *cmk_id_str, unsigned int *cmk_id)
{
    
    
    return true;
    const char *key_path_tag = "gs_ktool/";
    char tmp_str[MAX_KEYPATH_LEN] = {0};
    int tmp_pos = 0;
    bool has_invalid_char = false;

    if (cmk_id_str == NULL || strlen(cmk_id_str) <= strlen(key_path_tag)) {
        printf("ERROR(CLIENT): Invalid key path, it should be like \"%s1\".\n", key_path_tag);
        return false;
    }

    for (size_t i = 0; i < strlen(key_path_tag); i++) {
        if (cmk_id_str[i] != key_path_tag[i]) {
            printf("ERROR(CLIENT): Invalid key path, it should be like \"%s1\".\n", key_path_tag);
            return false;
        }
    }

    for (size_t i = strlen(key_path_tag); i < strlen(cmk_id_str); i++) {
        if (cmk_id_str[i] < '0' || cmk_id_str[i] > '9') {
            has_invalid_char = true;
        }
        tmp_str[tmp_pos] = cmk_id_str[i];
        tmp_pos++;
    }

    if (has_invalid_char) {
        printf("ERROR(CLIENT): Invalid key path, '%s' is expected to be an integer.\n", tmp_str);
        return false;
    }

    tmp_str[tmp_pos] = '\0';
    *cmk_id = atoi(tmp_str);

    return true;
}

bool encrypt_cek_with_aes_256(const unsigned char *cek_plain, size_t cek_plain_size, unsigned char *cmk_plain,
    unsigned char *cek_ciph, size_t &cek_ciph_len, bool is_report_err)
{
    /* use cmk_plian to generate derived_cmk_plain */
    AeadAesHamcEncKey aes_and_hmac_cek = AeadAesHamcEncKey(cmk_plain, (size_t)DEFAULT_CMK_LEN);
    AeadAesHamcEncKey *p_aes_and_hmac_cek = &aes_and_hmac_cek;
    EncryptionType enc_type = EncryptionType::DETERMINISTIC_TYPE;

    /* encrypt cek with cmk */
    cek_ciph_len =
        encrypt_data(cek_plain, cek_plain_size, *p_aes_and_hmac_cek, enc_type, cek_ciph, AEAD_AES_256_CBC_HMAC_SHA256);
    if (cek_ciph_len <= 0 && is_report_err) {
        if (is_report_err) {
            printf("ERROR(CLIENT): Fail to encrypt cek with cmk.\n");
        }
        return false;
    }

    return true;
}

bool decrypt_cek_with_aes_256(const unsigned char *cek_ciphe, size_t cek_ciphe_size, unsigned char *cmk_plain,
    unsigned char *cek_plain, size_t *cek_plain_len, bool is_report_err)
{
    AeadAesHamcEncKey derived_cmk_plain = AeadAesHamcEncKey(cmk_plain, (size_t)DEFAULT_CMK_LEN);
    AeadAesHamcEncKey *p_derived_cmk_plain = &derived_cmk_plain;

    *cek_plain_len =
        decrypt_data(cek_ciphe, cek_ciphe_size, *p_derived_cmk_plain, cek_plain, AEAD_AES_256_CBC_HMAC_SHA256);
    if (*cek_plain_len <= 0) {
        if (is_report_err) {
            printf("ERROR(CLIENT): Fail to dencrypt cek with cmk.\n");
        }
        return false;
    }

    return true;
}

void free_cmk_plain_cache()
{
    free_cmk_cache_list(cmk_cache_list);
}
